[33mcommit 472b372eb125f774518ef0063761db400ca7a680[m[33m ([m[1;36mHEAD[m[33m -> [m[1;32mmain[m[33m, [m[1;31morigin/main[m[33m, [m[1;31morigin/HEAD[m[33m)[m
Author: Martin Leung <martin.leung.ht@gmail.com>
Date:   Fri Mar 28 14:29:47 2025 +0000

    merged asyncio implementation

[1mdiff --git a/backendasyncrewrite.py b/backendasyncrewrite.py[m
[1mdeleted file mode 100644[m
[1mindex 17bce2e..0000000[m
[1m--- a/backendasyncrewrite.py[m
[1m+++ /dev/null[m
[36m@@ -1,495 +0,0 @@[m
[31m-from enum import Enum[m
[31m-import json[m
[31m-import time[m
[31m-import signal[m
[31m-import sys[m
[31m-import serial[m
[31m-import asyncio[m
[31m-import serial_asyncio[m
[31m-import os[m
[31m-import platform[m
[31m-[m
[31m-class MachineStates(Enum):[m
[31m-    IDLE = 1[m
[31m-    ABORT = 2[m
[31m-    HOTFIRE = 3[m
[31m-    LAUNCH = 4[m
[31m-    HOVER = 5[m
[31m-[m
[31m-class StateMachine:[m
[31m-    def __init__(self):[m
[31m-        self.state = MachineStates.IDLE[m
[31m-[m
[31m-    def set_state(self, state):[m
[31m-        if isinstance(state, MachineStates):[m
[31m-            self.state = state[m
[31m-        else:[m
[31m-            raise ValueError("Invalid state")[m
[31m-[m
[31m-    def get_state(self):[m
[31m-        return self.state[m
[31m-[m
[31m-    def __str__(self):[m
[31m-        return f"Current State: {self.state.name}"[m
[31m-[m
[31m-class SerialManager:[m
[31m-    def __init__(self, port, baudrate, print_send=False, print_recieve=False, emulator=False):[m
[31m-        self.emulator = emulator[m
[31m-        self.port = port[m
[31m-        self.baudrate = baudrate[m
[31m-        self.print_send = print_send[m
[31m-        self.print_recieve = print_recieve[m
[31m-        self.running = False[m
[31m-[m
[31m-        self.read_buffer = {}[m
[31m-        self.buffer_lock = asyncio.Lock()[m
[31m-        self.send_id = 0[m
[31m-        self.send_id_lock = asyncio.Lock()[m
[31m-[m
[31m-        self.cleanup_queue = []  # Will store (timestamp, id) tuples[m
[31m-        self.cleanup_lock = asyncio.Lock()[m
[31m-[m
[31m-        self.reader = None[m
[31m-        self.writer = None[m
[31m-        self.loop = asyncio.get_event_loop()[m
[31m-[m
[31m-    async def initialize(self):[m
[31m-        """Initialize the serial connection"""[m
[31m-        if self.emulator:[m
[31m-            print("SERIALMANAGER Emulator mode - no serial connection")[m
[31m-            return None[m
[31m-        [m
[31m-        return await self._initialize_serial()[m
[31m-[m
[31m-    async def _initialize_serial(self):[m
[31m-        try:[m
[31m-            self.reader, self.writer = await serial_asyncio.open_serial_connection([m
[31m-                url=self.port,[m
[31m-                baudrate=self.baudrate[m
[31m-            )[m
[31m-            print(f"SERIALMANAGER Serial port {self.port} opened at {self.baudrate} baud")[m
[31m-            [m
[31m-            # Start the background reading thread[m
[31m-            self.running = True[m
[31m-[m
[31m-            self.read_task = self.loop.create_task(self._read_loop())[m
[31m-            self.cleanup_task = self.loop.create_task(self._readbuffer_cleanloop())[m
[31m-[m
[31m-            return True[m
[31m-            [m
[31m-        except serial.SerialException as e:[m
[31m-            print(f"SERIALMANAGER Error opening port {self.port}: {e}")[m
[31m-            self.reader = None[m
[31m-            self.writer = None[m
[31m-            return False[m
[31m-[m
[31m-    async def _read_loop(self):[m
[31m-        """Background thread that continuously reads from serial port"""[m
[31m-        while self.running:[m
[31m-            try:[m
[31m-                line = await self.reader.readline()[m
[31m-                if line:[m
[31m-                    data = line.decode('utf-8').strip()[m
[31m-                    if data:[m
[31m-                        if self.print_recieve:[m
[31m-                            print(f"SERIALMANAGER Received: {data}")[m
[31m-                        try:[m
[31m-                            message_json = json.loads(data)[m
[31m-                            if "send_id" in message_json:[m
[31m-                                async with self.buffer_lock:[m
[31m-                                    self.read_buffer[message_json["send_id"]] = message_json[m
[31m-                                cleanup_time = time.perf_counter() + 1.0  # 1 second timeout[m
[31m-                                async with self.cleanup_lock:[m
[31m-                                    self.cleanup_queue.append((cleanup_time, message_json["send_id"]))[m
[31m-                        except json.JSONDecodeError:[m
[31m-                            print(f"SERIALMANAGER JSON Decode error: {data}")[m
[31m-            except Exception as e:[m
[31m-                print(f"SERIALMANAGER Read error: {e}")[m
[31m-                await asyncio.sleep(0.1)  # Longer sleep on error[m
[31m-[m
[31m-    async def _readbuffer_cleanloop(self):[m
[31m-        while self.running:[m
[31m-            try:[m
[31m-                next_cleanup_time = None[m
[31m-                cleanup_id = None[m
[31m-                [m
[31m-                async with self.cleanup_lock:[m
[31m-                    if self.cleanup_queue:[m
[31m-                        self.cleanup_queue.sort()[m
[31m-                        now = time.perf_counter()   [m
[31m-[m
[31m-                        while self.cleanup_queue and self.cleanup_queue[0][0] < now:[m
[31m-                            _, cleanup_id = self.cleanup_queue.pop(0)[m
[31m-                            async with self.buffer_lock:[m
[31m-                                if cleanup_id in self.read_buffer:[m
[31m-                                    print("SERIALMANAGER Cleanup: Removing message with send_id", cleanup_id)[m
[31m-                                    del self.read_buffer[cleanup_id][m
[31m-                        [m
[31m-                        if self.cleanup_queue:[m
[31m-                            next_cleanup_time = self.cleanup_queue[0][0][m
[31m-                if next_cleanup_time is not None:[m
[31m-                    await asyncio.sleep(max(0.1, next_cleanup_time - time.perf_counter()))[m
[31m-                else:[m
[31m-                    await asyncio.sleep(0.1)[m
[31m-            except Exception as e:[m
[31m-                print(f"SERIALMANAGER Cleanup error: {e}")[m
[31m-                await asyncio.sleep(0.1)[m
[31m-[m
[31m-    def send_receive(self, message_json, sendresponse_lambda):[m
[31m-        """Send message to serial port (non-blocking)"""[m
[31m-        if not self.writer:[m
[31m-            print("SERIALMANAGER Error: Serial port not open")[m
[31m-        [m
[31m-        self.loop.create_task(self._async_send_receive(message_json, sendresponse_lambda))[m
[31m-        [m
[31m-    async def _async_send_receive(self, message_json, sendresponse_lambda):[m
[31m-        try:[m
[31m-            async with self.send_id_lock:[m
[31m-                send_id = self.send_id[m
[31m-                self.send_id += 1[m
[31m-            message_json["send_id"] = send_id[m
[31m-            message = json.dumps(message_json)[m
[31m-[m
[31m-            self.writer.write(message.encode())[m
[31m-            await self.writer.drain()[m
[31m-[m
[31m-            if self.print_send:[m
[31m-                print(f"SERIALMANAGER Sent: {message.strip()}")[m
[31m-[m
[31m-            start_time = time.perf_counter()[m
[31m-            timeout_time = 1.0  # 1 second timeout[m
[31m-            while True:[m
[31m-                async with self.buffer_lock:[m
[31m-                    if send_id in self.read_buffer:[m
[31m-                        response = json.dumps(self.read_buffer[send_id])[m
[31m-                        sendresponse_lambda(response)[m
[31m-                        del self.read_buffer[send_id][m
[31m-                        return[m
[31m-                if time.perf_counter() - start_time > timeout_time:[m
[31m-                    print(f"SERIALMANAGER Timeout waiting for response with send_id {send_id}")[m
[31m-                    sendresponse_lambda(f"SERIALMANAGER Timeout waiting for response with send_id {send_id}")[m
[31m-                    return[m
[31m-                await asyncio.sleep(0.001)[m
[31m-        except Exception as e:[m
[31m-            print(f"SERIALMANAGER Send error: {e}")[m
[31m-            sendresponse_lambda(f"SERIALMANAGER Send error: {e}")[m
[31m-            return[m
[31m-[m
[31m-    def is_connected(self):[m
[31m-        """Check if serial connection is active"""[m
[31m-        return self.reader is not None and self.writer is not None[m
[31m-        [m
[31m-    def close(self):[m
[31m-        """Close the serial connection gracefully"""[m
[31m-        self.running = False[m
[31m-[m
[31m-        if hasattr(self, 'read_task'):[m
[31m-            self.read_task.cancel()[m
[31m-        if hasattr(self, 'cleanup_task'):[m
[31m-            self.cleanup_task.cancel()[m
[31m-[m
[31m-        if self.writer:[m
[31m-            self.writer.close()[m
[31m-            print(f"SERIALMANAGER Serial port {self.port} closed")[m
[31m-[m
[31m-[m
[31m-class HardwareHandler:[m
[31m-    def __init__(self, emulator=False):[m
[31m-        self.emulator = emulator[m
[31m-        self.serial_managers = {}[m
[31m-[m
[31m-        with open('hardware_config.json', 'r') as file:[m
[31m-            self.config = json.load(file)[m
[31m-        with open('hardware_config.json', 'w') as file:[m
[31m-                json.dump(self.config, file, indent=4)[m
[31m-[m
[31m-        [m
[31m-    async def initialize(self):[m
[31m-        """Initialize all hardware asynchronously"""[m
[31m-        return await self.load_hardware()[m
[31m-    [m
[31m-    async def load_hardware(self):[m
[31m-        # Initialize serial managers for each board in the configuration[m
[31m-        if 'boards' in self.config:[m
[31m-            for board in self.config['boards']:[m
[31m-                board_name = board['board_name'][m
[31m-                serial_config = board['serial'][m
[31m-                [m
[31m-                if 'port' in serial_config and 'baudrate' in serial_config:[m
[31m-                    try:[m
[31m-                        manager = SerialManager([m
[31m-                            port=serial_config['port'],[m
[31m-                            baudrate=serial_config['baudrate'],[m
[31m-                            emulator=self.emulator[m
[31m-                        )[m
[31m-                        if await manager.initialize():                        [m
[31m-                            self.serial_managers[board_name] = manager[m
[31m-                            print(f"Initialized serial connection for board: {board_name}")[m
[31m-                    except Exception as e:[m
[31m-                        print(f"Failed to initialize serial for board {board_name}: {e}")[m
[31m-                else:[m
[31m-                    print(f"Board {board_name} is missing port or baudrate configuration")[m
[31m-        else:[m
[31m-            print("No boards found in configuration or invalid board configuration")[m
[31m-[m
[31m-    def unload_hardware(self):[m
[31m-        # Close all serial connections[m
[31m-        for board_name, manager in self.serial_managers.items():[m
[31m-            manager.close()[m
[31m-            print(f"Closed serial connection for board: {board_name}")[m
[31m-        self.serial_managers.clear()[m
[31m-[m
[31m-    def get_serial_manager(self, board_name) -> SerialManager:[m
[31m-        """Get the serial manager for a specific board"""[m
[31m-        return self.serial_managers.get(board_name, None)[m
[31m-[m
[31m-    def get_config(self):[m
[31m-        """Return the hardware configuration"""[m
[31m-        return self.config[m
[31m-    [m
[31m-    def set_config(self, data):[m
[31m-        """Set the hardware configuration"""[m
[31m-        try:[m
[31m-            self.config = json.loads(data)[m
[31m-            with open('hardware_config.json', 'w') as file:[m
[31m-                json.dump(self.config, file, indent=4)[m
[31m-            return "Hardware configuration updated successfully"[m
[31m-        except json.JSONDecodeError:[m
[31m-            return "Invalid JSON format"[m
[31m-        [m
[31m-    def reload_config(self):[m
[31m-        """Reload the hardware configuration from a file"""[m
[31m-        self.unload_hardware()  # Unload current hardware configuration[m
[31m-        self.load_hardware()[m
[31m-        return "Hardware configuration reloaded successfully"[m
[31m-        [m
[31m-    def send_receive(self, board_name, message, sendresponse_lambda):[m
[31m-        """Send a message to a specific board and receive the response"""[m
[31m-        manager = self.get_serial_manager(board_name)[m
[31m-        if manager:[m
[31m-            manager.send_receive(message, sendresponse_lambda)[m
[31m-        else:[m
[31m-            print(f"Board {board_name} not found")[m
[31m-            sendresponse_lambda(f"Board {board_name} not found")[m
[31m-[m
[31m-class CommandHandler:[m
[31m-    def __init__(self, state_machine: StateMachine, hardware_handler: HardwareHandler):[m
[31m-        self.state_machine = state_machine[m
[31m-        self.hardware_handler = hardware_handler[m
[31m-        self.commands = {[m
[31m-            "get hardware json": self.get_hardware_json,[m
[31m-            "set hardware json": self.set_hardware_json,[m
[31m-            "reload hardware json": self.reload_hardware_json,[m
[31m-            "send_receive": self.send_receive[m
[31m-        }[m
[31m-[m
[31m-    def process_message(self, command, socket, addr):[m
[31m-        message_json = json.loads(command)[m
[31m-        command = message_json["command"][m
[31m-        data = message_json["data"][m
[31m-        sendresponse_lambda = lambda x : socket.sendto(x.encode('utf-8'), addr)[m
[31m-        if command in self.commands:[m
[31m-            self.commands[command](data, sendresponse_lambda)[m
[31m-        else :[m
[31m-            sendresponse_lambda(f"Unknown command: {command}")[m
[31m-            print(f"Unknown command: {command}")[m
[31m-        [m
[31m-[m
[31m-    def get_hardware_json(self, _, sendresponse_lambda):[m
[31m-        sendresponse_lambda(json.dumps(self.hardware_handler.get_config()))[m
[31m-    [m
[31m-    def set_hardware_json(self, data, sendresponse_lambda):[m
[31m-        sendresponse_lambda(self.hardware_handler.set_config(data))[m
[31m-[m
[31m-    def reload_hardware_json(self, _, sendresponse_lambda):[m
[31m-        sendresponse_lambda(self.hardware_handler.reload_config())[m
[31m-[m
[31m-    def send_receive(self, data, sendresponse_lambda):[m
[31m-        try:[m
[31m-            board_name = data["board_name"][m
[31m-            message_json = data["message"][m
[31m-            self.hardware_handler.send_receive(board_name, message_json, sendresponse_lambda)[m
[31m-        except KeyError as e:[m
[31m-            return f"Missing key in data: {e}"  [m
[31m-[m
[31m-[m
[31m-[m
[31m-class UDPServer:[m
[31m-    def __init__(self, command_handler: CommandHandler, host='0.0.0.0', port=8888, print_send=False, print_recieve=False):[m
[31m-        self.command_handler = command_handler[m
[31m-        self.host = host[m
[31m-        self.port = port[m
[31m-        self.print_send = print_send[m
[31m-        self.print_recieve = print_recieve[m
[31m-[m
[31m-        self.running = False[m
[31m-        self.transport = None[m
[31m-        self.protocol = None[m
[31m-[m
[31m-        loop = asyncio.get_event_loop()[m
[31m-        loop.create_task(self._start_server())[m
[31m-[m
[31m-        print(f"UDP server listening on {self.host}:{self.port}")[m
[31m-[m
[31m-    async def _start_server(self):[m
[31m-        """Start the UDP server using asyncio"""[m
[31m-        class UDPServerProtocol(asyncio.DatagramProtocol):[m
[31m-            def __init__(self, server):[m
[31m-                self.server = server[m
[31m-                [m
[31m-            def connection_made(self, transport):[m
[31m-                self.server.transport = transport[m
[31m-                [m
[31m-            def datagram_received(self, data, addr):[m
[31m-                message = data.decode('utf-8').strip()[m
[31m-                if self.server.print_recieve:[m
[31m-                    print(f"UDP Received: '{message}' from {addr}")[m
[31m-                [m
[31m-                # Process the message[m
[31m-                self.server.command_handler.process_message([m
[31m-                    message, [m
[31m-                    lambda x: self.server.transport.sendto(x.encode('utf-8'), addr),[m
[31m-                    addr[m
[31m-                )[m
[31m-        [m
[31m-        loop = asyncio.get_event_loop()[m
[31m-        self.transport, self.protocol = await loop.create_datagram_endpoint([m
[31m-            lambda: UDPServerProtocol(self),[m
[31m-            local_addr=(self.host, self.port)[m
[31m-        )[m
[31m-        # while self.running:[m
[31m-        #     try:[m
[31m-        #         data, addr = self.socket.recvfrom(1024)[m
[31m-        #         message = data.decode('utf-8').strip()[m
[31m-        #         if self.print_recieve:[m
[31m-        #             print(f"UDP Received: '{message}' from {addr}")[m
[31m-        #         self.command_handler.process_message(message, self.socket, addr)[m
[31m-        #     except Exception as e:[m
[31m-        #         if self.running:[m
[31m-        #             print(f"UDP Error: {e}")[m
[31m-    [m
[31m-    def stop(self):[m
[31m-        """Stop the server"""[m
[31m-        if self.transport:[m
[31m-            self.transport.close()[m
[31m-        print("UDP Server stopped")[m
[31m-[m
[31m-[m
[31m-class SignalHandler:[m
[31m-    def __init__(self, udp_server, emulator=False):[m
[31m-        self.udp_server = udp_server[m
[31m-        signal.signal(signal.SIGINT, self.handle_signal)  # Handle Ctrl+C[m
[31m-        signal.signal(signal.SIGTERM, self.handle_signal)  # Handle termination[m
[31m-        if(not emulator):[m
[31m-            signal.signal(signal.SIGTSTP, self.handle_suspend)[m
[31m-[m
[31m-    def handle_signal(self, signum, frame):[m
[31m-        print(f"Received signal {signum}, stopping server...")[m
[31m-        self.udp_server.stop()[m
[31m-        sys.exit(0)[m
[31m-[m
[31m-    def handle_suspend(self, signum, frame):[m
[31m-        """Handle process suspension (Ctrl+Z)"""[m
[31m-        print("\nProcess being suspended, cleaning up resources...")[m
[31m-        self.udp_server.stop()[m
[31m-        # Re-raise SIGTSTP to actually suspend after cleanup[m
[31m-        signal.signal(signal.SIGTSTP, signal.SIG_DFL)[m
[31m-        os.kill(os.getpid(), signal.SIGTSTP)[m
[31m-[m
[31m-class TimeKeeper:[m
[31m-    def __init__(self, cycle_time=0.01):[m
[31m-        self.cycle_time = cycle_time[m
[31m-        self.start_time = time.perf_counter()[m
[31m-        self.cycle = 0[m
[31m-[m
[31m-    def cycle_start(self):[m
[31m-        self.cycle_starttime = time.perf_counter()[m
[31m-        [m
[31m-[m
[31m-    async def cycle_end(self):[m
[31m-        self.cycle += 1[m
[31m-        elapsed = time.perf_counter() - self.cycle_starttime[m
[31m-        sleep_time = max(0, self.cycle_time - elapsed)[m
[31m-        if sleep_time > 0:[m
[31m-            await asyncio.sleep(sleep_time)[m
[31m-        else:[m
[31m-            await asyncio.sleep(0) #To yield to event loop briefly[m
[31m-[m
[31m-    def get_cycle(self):[m
[31m-        return self.cycle[m
[31m-[m
[31m-async def main(emulator=False):[m
[31m-    deployment_power = False[m
[31m-[m
[31m-    state_machine = StateMachine()[m
[31m-